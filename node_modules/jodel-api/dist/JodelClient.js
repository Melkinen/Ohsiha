"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const node_fetch_1 = require("node-fetch");
const humps = require("humps");
const querystring = require("querystring");
class JodelAPI {
    constructor(config, accessToken) {
        this.config = config;
        this.accessToken = accessToken;
    }
    post(path, queryParams = {}, body) {
        return this.doRequest("post", path, this.accessToken, queryParams, body);
    }
    get(path, queryParams = {}) {
        return this.doRequest("get", path, this.accessToken, queryParams, null);
    }
    delete(path, queryParams, body) {
        return this.doRequest("delete", path, this.accessToken, queryParams, body);
    }
    put(path, queryParams, body) {
        return this.doRequest("put", path, this.accessToken, queryParams, body);
    }
    postUnverified(path, queryParams, body) {
        return this.doRequest("post", path, undefined, queryParams, body);
    }
    doRequest(method, path, accessToken, queryParams, body) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.config.endpoint + path;
            let qs = "";
            if (queryParams) {
                queryParams = queryParams ? queryParams : {};
                queryParams = humps.decamelizeKeys(queryParams);
                qs = querystring.stringify(queryParams);
                if (qs && qs.length > 0) {
                    if (!url.endsWith("?"))
                        url += "?";
                    url += qs;
                }
            }
            if (body) {
                body = humps.decamelizeKeys(body);
            }
            let headers = this.createHeaders(accessToken);
            const bodyStr = body ? JSON.stringify(body) : "";
            headers = yield this.config.signHeaders(method, "/api" + path, new Date(), qs, bodyStr, headers);
            const init = {
                body: bodyStr,
                method,
                headers
            };
            const res = yield node_fetch_1.default(url, init);
            if (!res.ok) {
                const rejection = {
                    code: res.status,
                    text: res.statusText,
                    content: yield res.text()
                };
                return Promise.reject(rejection);
            }
            const resObj = yield res.json();
            const convertedCase = humps.camelizeKeys(resObj);
            return convertedCase;
        });
    }
    createHeaders(accessToken) {
        let headers = {
            "User-Agent": this.config.userAgent,
            "Content-Type": "application/json",
        };
        if (accessToken)
            headers["Authorization"] = `Bearer ${this.accessToken}`;
        return headers;
    }
    getChannelCombo(channel) {
        return this.get(`/v3/posts/channel/combo`, { channel: channel });
    }
    getDiscussedChannelPosts(channel, after) {
        return this.get("/v3/posts/channel/discussed", { channel: channel, after: after }).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getKarma() {
        return this.get("/v2/users/karma");
    }
    getModerationFeed() {
        return this.get("/v3/moderation");
    }
    getMostDiscussedPosts(position, after) {
        const params = {};
        if (after)
            params["after"] = after;
        if (position) {
            params["lat"] = position.lat;
            params["lng"] = position.lng;
        }
        return this.get("/v2/posts/location/discussed", params).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMostPopularPosts(position, after) {
        const params = {};
        if (after)
            params["after"] = after;
        if (position) {
            params["lat"] = position.lat;
            params["lng"] = position.lng;
        }
        return this.get("/v2/posts/location/popular", params).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMostRecentPosts(position, after) {
        const params = {};
        if (after)
            params["after"] = after;
        if (position) {
            params["lat"] = position.lat;
            params["lng"] = position.lng;
        }
        return this.get("/v2/posts/location/", params).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyMostDiscussedPosts(pagination) {
        return this.get("/v2/posts/location/", pagination).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyPinnedPosts(pagination = null) {
        return this.get("/v2/posts/mine/pinned/", pagination ? pagination : {}).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyPopularPosts(pagination) {
        return this.get("/v2/posts/mine/popular/", pagination).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyPosts(pagination) {
        return this.get("/v2/posts/mine/", pagination).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyPostsCombo() {
        return this.get("/v2/posts/mine/combo");
    }
    getMyRepliedPosts(pagination = null) {
        return this.get("/v2/posts/mine/replies/", pagination ? pagination : {}).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getMyVotedPosts(pagination = null) {
        return this.get("/v2/posts/mine/votes/", pagination ? pagination : {}).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getPopularChannelPosts(channel, after) {
        const params = {};
        if (after)
            params["after"] = after;
        if (channel)
            params["channel"] = channel;
        return this.get("/v3/posts/channel/popular", params).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
    }
    getPost(postId, highlight) {
        return this.get(`/v2/posts/${postId}/`, { highlight: highlight ? highlight : null }).then(p => JodelAPI.fixPost(p));
    }
    deletePost(postId) {
        return this.delete(`/v2/posts/${postId}`, {}, null);
    }
    getRecentChannelPosts(channel, after) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (after)
                params["after"] = after;
            if (channel)
                params["channel"] = channel;
            return this.get("/v3/posts/channel", params).then(ps => { JodelAPI.fixPosts(ps.posts); return ps; });
        });
    }
    getUserConfig() {
        return this.get("/v3/user/config");
    }
    downvotePost(postId) {
        return this.put(`/v2/posts/${postId}/downvote`, {}, null);
    }
    flagPost(postId, reason) {
        return this.put(`/v2/posts/${postId}/flag`, {}, reason);
    }
    followChannel(channel) {
        return this.put("/v3/user/followChannel", { channel }, null);
    }
    pinPost(postId) {
        return this.put(`/v2/posts/${postId}/pin`, {}, null);
    }
    sendLogs(data) {
        return this.put("/v3/investigate", {}, data);
    }
    sendPushToken(data) {
        return this.put("/v2/users/pushToken", {}, data);
    }
    sendUserLocation(data) {
        return this.put("/v2/users/location", {}, data);
    }
    unfollowChannel(channel) {
        return this.put("/v3/user/unfollowChannel", { channel }, null);
    }
    unpinPost(postId) {
        return this.put(`/v2/posts/${postId}/unpin`, {}, null);
    }
    upvotePost(postId) {
        return this.put(`/v2/posts/${postId}/upvote`, {}, null);
    }
    dismissStickyPost(id) {
        return this.put(`/v3/stickyposts/${id}/dismiss`, {}, null);
    }
    downvoteStickyPost(id) {
        return this.put(`/v3/stickyposts/${id}/down`, {}, null);
    }
    upvoteStickyPost(id) {
        return this.put(`/v3/stickyposts/${id}/up`, {}, null);
    }
    getNewAccessToken(data) {
        return this.post("/v2/users/refreshToken", {}, data);
    }
    getRequestToken(data) {
        return this.post("/v2/users", {}, data);
    }
    sendModerationResult(data) {
        return this.post("/v3/moderation", {}, data);
    }
    sendPost(data) {
        const demData = data;
        const img = demData.image;
        if (img && img instanceof Buffer) {
            demData.image = img.toString("base64");
        }
        return this.post("/v2/posts/", {}, data);
    }
    sendUserType(data) {
        return this.post("/v3/user/school_screen", {}, data);
    }
    trackAction(data) {
        return this.post("/v3/action", {}, data);
    }
    getFollowedChannelsMeta(map) {
        return this.post("/v3/user/followedChannelsMeta", {}, map);
    }
    getPostsCombo(pos, stickies) {
        return this.get("/v3/posts/location/combo", { lat: pos.lat, lng: pos.lng, stickies });
    }
    getRecommendedChannels() {
        return this.get("/v3/user/recommendedChannels");
    }
    static fixPosts(ps) {
        for (const p of ps)
            JodelAPI.fixPost(p);
        return ps;
    }
    static fixPost(p) {
        if (typeof p.createdAt === "string")
            p.createdAt = new Date(p.createdAt);
        if (typeof p.updatedAt === "string")
            p.updatedAt = new Date(p.updatedAt);
        if (p.children && p.children.length > 0) {
            for (let i = 0; i < p.children.length; ++i) {
                p.children[i] = JodelAPI.fixPost(p.children[i]);
            }
        }
        return p;
    }
}
class JodelClient {
    constructor(config, _accessToken) {
        this.config = config;
        this._accessToken = _accessToken;
        this.api = new JodelAPI(config, _accessToken);
    }
    get accessToken() {
        return this._accessToken;
    }
    login(location) {
        return this.register(location);
    }
    register(location) {
        return __awaiter(this, void 0, void 0, function* () {
            const authRes = yield this.api.getRequestToken({
                clientId: this.config.clientId,
                deviceUid: this.config.deviceUID,
                location: location
            });
            if (!authRes.accessToken)
                return Promise.reject("No access token provided");
            this._accessToken = authRes.accessToken;
            this.api.accessToken = this._accessToken;
        });
    }
    loginWithToken(accessToken) {
        if (!accessToken)
            return Promise.reject("No access token provided");
        this._accessToken = accessToken;
        this.api.accessToken = accessToken;
        return Promise.resolve();
    }
    updateLocation(countryCode, lat, long, accuracy = JodelClient.randomAccuracy()) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        countryCode = countryCode.toUpperCase();
        return this.api.sendUserLocation({
            location: {
                country: countryCode,
                locAccuracy: accuracy || 0.0,
                locCoordinates: {
                    lat: lat,
                    lng: long
                }
            }
        });
    }
    postImage(image, color, location) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.sendPost({
            image,
            location,
            color
        });
    }
    post(message, color, location) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.sendPost({
            message,
            location,
            color
        });
    }
    reply(ancestor, message, location) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.sendPost({
            ancestor,
            message,
            location
        });
    }
    getMostPopularPosts(position, after) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.getMostPopularPosts(position, after);
    }
    getMostDiscussedPosts(position, after) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.getMostDiscussedPosts(position, after);
    }
    getMostRecentPosts(position, after) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.getMostRecentPosts(position, after);
    }
    getPost(id, highlight) {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.getPost(id, highlight);
    }
    getKarma() {
        if (!this.accessToken)
            return Promise.reject("No access token provided");
        return this.api.getKarma();
    }
    static randomAccuracy() {
        return Math.floor(Math.random() * 21);
    }
}
exports.JodelClient = JodelClient;
